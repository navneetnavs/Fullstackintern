{"ast":null,"code":"// Mocked API service for PII image masking\nconst API_BASE_URL = '/api';\n\n// Simulate different masking techniques\nconst applyMaskingStyle = (ctx, area, style, img) => {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = area;\n  switch (style) {\n    case 'blur':\n      // Create a blurred version of the area\n      const imageData = ctx.getImageData(x, y, width, height);\n      const blurredData = applyGaussianBlur(imageData, 15);\n      ctx.putImageData(blurredData, x, y);\n      break;\n    case 'pixelate':\n      // Pixelate the area\n      const pixelSize = Math.max(8, Math.min(width, height) / 10);\n      for (let px = x; px < x + width; px += pixelSize) {\n        for (let py = y; py < y + height; py += pixelSize) {\n          const sampleData = ctx.getImageData(px, py, 1, 1).data;\n          ctx.fillStyle = `rgb(${sampleData[0]}, ${sampleData[1]}, ${sampleData[2]})`;\n          ctx.fillRect(px, py, pixelSize, pixelSize);\n        }\n      }\n      break;\n    case 'blackbar':\n    default:\n      // Black bar with text\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';\n      ctx.fillRect(x, y, width, height);\n      ctx.fillStyle = 'white';\n      ctx.font = `${Math.max(12, height * 0.4)}px Arial`;\n      ctx.textAlign = 'center';\n      ctx.fillText('MASKED', x + width / 2, y + height * 0.6);\n      break;\n  }\n};\n\n// Simple Gaussian blur implementation\nconst applyGaussianBlur = (imageData, radius) => {\n  const data = imageData.data;\n  const width = imageData.width;\n  const height = imageData.height;\n  const output = new Uint8ClampedArray(data);\n  const kernel = createGaussianKernel(radius);\n  const kernelSize = kernel.length;\n  const half = Math.floor(kernelSize / 2);\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let r = 0,\n        g = 0,\n        b = 0,\n        a = 0;\n      for (let ky = 0; ky < kernelSize; ky++) {\n        for (let kx = 0; kx < kernelSize; kx++) {\n          const px = Math.min(width - 1, Math.max(0, x + kx - half));\n          const py = Math.min(height - 1, Math.max(0, y + ky - half));\n          const idx = (py * width + px) * 4;\n          const weight = kernel[ky][kx];\n          r += data[idx] * weight;\n          g += data[idx + 1] * weight;\n          b += data[idx + 2] * weight;\n          a += data[idx + 3] * weight;\n        }\n      }\n      const idx = (y * width + x) * 4;\n      output[idx] = r;\n      output[idx + 1] = g;\n      output[idx + 2] = b;\n      output[idx + 3] = a;\n    }\n  }\n  return new ImageData(output, width, height);\n};\nconst createGaussianKernel = radius => {\n  const size = radius * 2 + 1;\n  const kernel = [];\n  const sigma = radius / 3;\n  let sum = 0;\n  for (let y = 0; y < size; y++) {\n    kernel[y] = [];\n    for (let x = 0; x < size; x++) {\n      const distance = Math.sqrt((x - radius) ** 2 + (y - radius) ** 2);\n      const value = Math.exp(-(distance ** 2) / (2 * sigma ** 2));\n      kernel[y][x] = value;\n      sum += value;\n    }\n  }\n\n  // Normalize kernel\n  for (let y = 0; y < size; y++) {\n    for (let x = 0; x < size; x++) {\n      kernel[y][x] /= sum;\n    }\n  }\n  return kernel;\n};\n\n// Generate realistic PII detection areas\nconst generatePIIAreas = (width, height) => {\n  const areas = [];\n  const detectedPII = {\n    faces: 0,\n    textRegions: 0,\n    idNumbers: 0,\n    addresses: 0\n  };\n\n  // Simulate face detection (1-3 faces)\n  const faceCount = Math.floor(Math.random() * 3) + 1;\n  for (let i = 0; i < faceCount; i++) {\n    areas.push({\n      type: 'face',\n      x: Math.random() * (width * 0.6),\n      y: Math.random() * (height * 0.4),\n      width: width * (0.15 + Math.random() * 0.1),\n      height: height * (0.2 + Math.random() * 0.1)\n    });\n    detectedPII.faces++;\n  }\n\n  // Simulate text regions (0-4 text areas)\n  const textCount = Math.floor(Math.random() * 5);\n  for (let i = 0; i < textCount; i++) {\n    areas.push({\n      type: 'text',\n      x: Math.random() * (width * 0.7),\n      y: Math.random() * (height * 0.8),\n      width: width * (0.2 + Math.random() * 0.3),\n      height: height * (0.03 + Math.random() * 0.04)\n    });\n\n    // Categorize text types\n    const textType = Math.random();\n    if (textType < 0.4) detectedPII.textRegions++;else if (textType < 0.7) detectedPII.idNumbers++;else detectedPII.addresses++;\n  }\n  return {\n    areas,\n    detectedPII\n  };\n};\n\n// Create masked image with specified style\nconst createMaskedImage = (originalImage, maskingStyle = 'blackbar') => {\n  return new Promise(resolve => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const img = new Image();\n    img.onload = () => {\n      canvas.width = img.width;\n      canvas.height = img.height;\n\n      // Draw original image\n      ctx.drawImage(img, 0, 0);\n\n      // Generate PII areas\n      const {\n        areas,\n        detectedPII\n      } = generatePIIAreas(img.width, img.height);\n\n      // Apply masking to each area\n      areas.forEach(area => {\n        applyMaskingStyle(ctx, area, maskingStyle, img);\n      });\n\n      // Convert canvas to blob\n      canvas.toBlob(blob => {\n        const maskedImageUrl = URL.createObjectURL(blob);\n        resolve({\n          maskedImageUrl,\n          detectedPII\n        });\n      }, 'image/png');\n    };\n    img.src = originalImage;\n  });\n};\nexport const maskImage = async imageFile => {\n  // Simulate API delay\n  const delay = Math.random() * 2000 + 1500; // 1.5-3.5 seconds\n\n  return new Promise(async (resolve, reject) => {\n    try {\n      // Simulate potential API failures (10% chance)\n      if (Math.random() < 0.1) {\n        setTimeout(() => {\n          reject(new Error('API service temporarily unavailable. Please try again.'));\n        }, delay);\n        return;\n      }\n\n      // Create object URL from the uploaded file\n      const originalImageUrl = URL.createObjectURL(imageFile);\n      setTimeout(async () => {\n        try {\n          const maskedImageUrl = await createMaskedImage(originalImageUrl);\n\n          // Clean up the original object URL\n          URL.revokeObjectURL(originalImageUrl);\n          resolve({\n            success: true,\n            maskedImageUrl,\n            message: 'Image processed successfully',\n            detectedPII: ['Personal Name', 'Phone Number', 'Email Address']\n          });\n        } catch (error) {\n          reject(new Error('Failed to process image. Please try again.'));\n        }\n      }, delay);\n    } catch (error) {\n      reject(new Error('Failed to upload image. Please check your file and try again.'));\n    }\n  });\n};\nexport const checkApiHealth = async () => {\n  // Mock health check\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({\n        status: 'healthy',\n        timestamp: new Date().toISOString()\n      });\n    }, 500);\n  });\n};","map":{"version":3,"names":["API_BASE_URL","applyMaskingStyle","ctx","area","style","img","x","y","width","height","imageData","getImageData","blurredData","applyGaussianBlur","putImageData","pixelSize","Math","max","min","px","py","sampleData","data","fillStyle","fillRect","font","textAlign","fillText","radius","output","Uint8ClampedArray","kernel","createGaussianKernel","kernelSize","length","half","floor","r","g","b","a","ky","kx","idx","weight","ImageData","size","sigma","sum","distance","sqrt","value","exp","generatePIIAreas","areas","detectedPII","faces","textRegions","idNumbers","addresses","faceCount","random","i","push","type","textCount","textType","createMaskedImage","originalImage","maskingStyle","Promise","resolve","canvas","document","createElement","getContext","Image","onload","drawImage","forEach","toBlob","blob","maskedImageUrl","URL","createObjectURL","src","maskImage","imageFile","delay","reject","setTimeout","Error","originalImageUrl","revokeObjectURL","success","message","error","checkApiHealth","status","timestamp","Date","toISOString"],"sources":["/Users/navneetkumar/Desktop/Agiledgewebsite/internshipassignment/internassign/Fullstackintern/src/services/apiService.js"],"sourcesContent":["// Mocked API service for PII image masking\nconst API_BASE_URL = '/api';\n\n// Simulate different masking techniques\nconst applyMaskingStyle = (ctx, area, style, img) => {\n  const { x, y, width, height } = area;\n  \n  switch (style) {\n    case 'blur':\n      // Create a blurred version of the area\n      const imageData = ctx.getImageData(x, y, width, height);\n      const blurredData = applyGaussianBlur(imageData, 15);\n      ctx.putImageData(blurredData, x, y);\n      break;\n      \n    case 'pixelate':\n      // Pixelate the area\n      const pixelSize = Math.max(8, Math.min(width, height) / 10);\n      for (let px = x; px < x + width; px += pixelSize) {\n        for (let py = y; py < y + height; py += pixelSize) {\n          const sampleData = ctx.getImageData(px, py, 1, 1).data;\n          ctx.fillStyle = `rgb(${sampleData[0]}, ${sampleData[1]}, ${sampleData[2]})`;\n          ctx.fillRect(px, py, pixelSize, pixelSize);\n        }\n      }\n      break;\n      \n    case 'blackbar':\n    default:\n      // Black bar with text\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';\n      ctx.fillRect(x, y, width, height);\n      ctx.fillStyle = 'white';\n      ctx.font = `${Math.max(12, height * 0.4)}px Arial`;\n      ctx.textAlign = 'center';\n      ctx.fillText('MASKED', x + width / 2, y + height * 0.6);\n      break;\n  }\n};\n\n// Simple Gaussian blur implementation\nconst applyGaussianBlur = (imageData, radius) => {\n  const data = imageData.data;\n  const width = imageData.width;\n  const height = imageData.height;\n  const output = new Uint8ClampedArray(data);\n  \n  const kernel = createGaussianKernel(radius);\n  const kernelSize = kernel.length;\n  const half = Math.floor(kernelSize / 2);\n  \n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let r = 0, g = 0, b = 0, a = 0;\n      \n      for (let ky = 0; ky < kernelSize; ky++) {\n        for (let kx = 0; kx < kernelSize; kx++) {\n          const px = Math.min(width - 1, Math.max(0, x + kx - half));\n          const py = Math.min(height - 1, Math.max(0, y + ky - half));\n          const idx = (py * width + px) * 4;\n          const weight = kernel[ky][kx];\n          \n          r += data[idx] * weight;\n          g += data[idx + 1] * weight;\n          b += data[idx + 2] * weight;\n          a += data[idx + 3] * weight;\n        }\n      }\n      \n      const idx = (y * width + x) * 4;\n      output[idx] = r;\n      output[idx + 1] = g;\n      output[idx + 2] = b;\n      output[idx + 3] = a;\n    }\n  }\n  \n  return new ImageData(output, width, height);\n};\n\nconst createGaussianKernel = (radius) => {\n  const size = radius * 2 + 1;\n  const kernel = [];\n  const sigma = radius / 3;\n  let sum = 0;\n  \n  for (let y = 0; y < size; y++) {\n    kernel[y] = [];\n    for (let x = 0; x < size; x++) {\n      const distance = Math.sqrt((x - radius) ** 2 + (y - radius) ** 2);\n      const value = Math.exp(-(distance ** 2) / (2 * sigma ** 2));\n      kernel[y][x] = value;\n      sum += value;\n    }\n  }\n  \n  // Normalize kernel\n  for (let y = 0; y < size; y++) {\n    for (let x = 0; x < size; x++) {\n      kernel[y][x] /= sum;\n    }\n  }\n  \n  return kernel;\n};\n\n// Generate realistic PII detection areas\nconst generatePIIAreas = (width, height) => {\n  const areas = [];\n  const detectedPII = {\n    faces: 0,\n    textRegions: 0,\n    idNumbers: 0,\n    addresses: 0\n  };\n  \n  // Simulate face detection (1-3 faces)\n  const faceCount = Math.floor(Math.random() * 3) + 1;\n  for (let i = 0; i < faceCount; i++) {\n    areas.push({\n      type: 'face',\n      x: Math.random() * (width * 0.6),\n      y: Math.random() * (height * 0.4),\n      width: width * (0.15 + Math.random() * 0.1),\n      height: height * (0.2 + Math.random() * 0.1)\n    });\n    detectedPII.faces++;\n  }\n  \n  // Simulate text regions (0-4 text areas)\n  const textCount = Math.floor(Math.random() * 5);\n  for (let i = 0; i < textCount; i++) {\n    areas.push({\n      type: 'text',\n      x: Math.random() * (width * 0.7),\n      y: Math.random() * (height * 0.8),\n      width: width * (0.2 + Math.random() * 0.3),\n      height: height * (0.03 + Math.random() * 0.04)\n    });\n    \n    // Categorize text types\n    const textType = Math.random();\n    if (textType < 0.4) detectedPII.textRegions++;\n    else if (textType < 0.7) detectedPII.idNumbers++;\n    else detectedPII.addresses++;\n  }\n  \n  return { areas, detectedPII };\n};\n\n// Create masked image with specified style\nconst createMaskedImage = (originalImage, maskingStyle = 'blackbar') => {\n  return new Promise((resolve) => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    \n    const img = new Image();\n    img.onload = () => {\n      canvas.width = img.width;\n      canvas.height = img.height;\n      \n      // Draw original image\n      ctx.drawImage(img, 0, 0);\n      \n      // Generate PII areas\n      const { areas, detectedPII } = generatePIIAreas(img.width, img.height);\n      \n      // Apply masking to each area\n      areas.forEach(area => {\n        applyMaskingStyle(ctx, area, maskingStyle, img);\n      });\n      \n      // Convert canvas to blob\n      canvas.toBlob((blob) => {\n        const maskedImageUrl = URL.createObjectURL(blob);\n        resolve({ maskedImageUrl, detectedPII });\n      }, 'image/png');\n    };\n    \n    img.src = originalImage;\n  });\n};\n\nexport const maskImage = async (imageFile) => {\n  // Simulate API delay\n  const delay = Math.random() * 2000 + 1500; // 1.5-3.5 seconds\n  \n  return new Promise(async (resolve, reject) => {\n    try {\n      // Simulate potential API failures (10% chance)\n      if (Math.random() < 0.1) {\n        setTimeout(() => {\n          reject(new Error('API service temporarily unavailable. Please try again.'));\n        }, delay);\n        return;\n      }\n      \n      // Create object URL from the uploaded file\n      const originalImageUrl = URL.createObjectURL(imageFile);\n      \n      setTimeout(async () => {\n        try {\n          const maskedImageUrl = await createMaskedImage(originalImageUrl);\n          \n          // Clean up the original object URL\n          URL.revokeObjectURL(originalImageUrl);\n          \n          resolve({\n            success: true,\n            maskedImageUrl,\n            message: 'Image processed successfully',\n            detectedPII: [\n              'Personal Name',\n              'Phone Number', \n              'Email Address'\n            ]\n          });\n        } catch (error) {\n          reject(new Error('Failed to process image. Please try again.'));\n        }\n      }, delay);\n      \n    } catch (error) {\n      reject(new Error('Failed to upload image. Please check your file and try again.'));\n    }\n  });\n};\n\nexport const checkApiHealth = async () => {\n  // Mock health check\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({\n        status: 'healthy',\n        timestamp: new Date().toISOString()\n      });\n    }, 500);\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}